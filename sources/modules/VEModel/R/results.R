# Results.R
#' @include environment.R
self=private=NULL

# Output just wraps a ModelState and Datastore for one stage
# It maintains everything we need for a QueryPrep_ls structure for queries
# Plus it can export slices of the Datastore into .csv or data.frame
ve.results.init <- function(OutputPath,ModelDir=NULL,Param_ls=NULL) {
  # OutputPath is the normalized path to a directory containing the model results
  #  typically from the last model stage. Expect to find a ModelState.Rda file
  #  and a Datastore in that folder.
  # mo
  # Param_ls is the list of Run Parameters used by the model
  self$resultsPath <- OutputPath
  self$modelDir <- if ( ! is.null(ModelDir) ) ModelDir else getwd()
  self$Name <- basename(OutputPath)
  private$RunParam_ls <- Param_ls;
    # NULL Param_ls will use default from VEModel::ve.env
    # In practice, if a VEResults object is created from an arbitrary path,
    #   we'll use the system parameters (loading VisionEval.cnv from ve.runtime/local/config/VisonEval.cnf if
    #   that path exists, otherwise looking in ve.runtime/VisionEval.cnf if that exists)
    # If we're coming from a VEModel, we'll use its RunParam_ls, which will
    #   read VisionEval.cnf from the path supplied to VEModel::new it it exists,
    #   otherwise reading defs/VisionEval.cnf if that exists
  self$index()
  self$selection <- VESelection$new(self)
  return(self$valid())
}

ve.results.valid <- function() {
  valid <- ! is.null(private$RunParam_ls) &&
           dir.exists(self$resultsPath) &&
           !is.null(self$modelIndex) && length(self$modelIndex)>0
  modelStateFile <- file.path(self$resultsPath,visioneval::getRunParameter("ModelStateFileName",Param_ls=private$RunParam_ls))
  valid <- valid && all(file.exists(modelStateFile))
  return(valid)
}

# Check if a specified attribute belongs to the Datastore row
attributeExist <- function(variable, attr_name){
  if(is.list(variable)){
    if(!is.na(variable[[1]])){
      attr_value <- variable[[attr_name]]
      if(!is.null(attr_value)) return(TRUE)
    }
  }
  return(FALSE)
}

# Get a specified attribute for a Datastore row
attributeGet <- function(variable, attr_name){
  if(is.list(variable)){
    if(!is.na(variable[[1]])){
      attr_value <- variable[[attr_name]]
      if(!is.null(attr_value)) return(attr_value)
    }
  }
  return(NA)
}

ve.results.index <- function() {
  # Load model state from self$resultsPath
  ve.model <- new.env()
  FileName=normalizePath( file.path(
    self$resultsPath, # Should already include ResultsDir
    visioneval::getModelStateFileName(Param_ls=private$RunParam_ls)
  ), winslash="/", mustWork=FALSE)
  ms <- self$ModelState <- try(visioneval::readModelState(FileName=FileName))
  if ( ! is.list(ms) ) {
    ms <- self$ModelState <- NULL
    visioneval::writeLog(Level="error",paste("Cannot load ModelState from:",FileName))
    return(list())
  }
  if ( is.null(private$RunParam_ls) && is.list( ms ) ) {
    private$RunParam_ls <-ms$RunParam_ls
  }
  owd <- setwd(self$resultsPath)
  on.exit(setwd(owd))

  if ( ! file.exists( ms$DatastoreName ) ) {
    message("Datastore for this model is not available. Has it run successfully?")
    return(list())
  }

  Index <- data.frame()
  Inputs <- data.frame()

  if ( length(ms)==0 ) {
    return(list())
  }
  if ( ! "Datastore" %in% names(ms) ) {
    message("Datastore not defined in ModelState: ",paste(names(ms),collapse=","))
    message("Clear model results and try again.")
    return(list())
  } else if ( ! is.list(ms$Datastore) ) {
    message("Datastore is incomplete: ",class(ms$Datastore)," ",length(ms$Datastore))
    message("Clear model results and try again.")
    return(list())
  }
  ds <- (ms$Datastore)

  Description <- sapply(ds$attributes, attributeGet, "DESCRIPTION",simplify=TRUE) # should yield a character vector
  Module <- sapply(ds$attributes, attributeGet, "MODULE",simplify=TRUE) # should yield a character vector
  Units <- sapply(ds$attributes, attributeGet, "UNITS",simplify=TRUE) # should yield a character vector
  InputDir <- sapply(ds$attributes, attributeGet, "INPUTDIR",simplify=TRUE) # should yield a character vector
  InputDir[ is.na(InputDir) ] <- ""
  File <- sapply(ds$attributes, attributeGet, "FILE",simplify=TRUE) # should yield a character vector
  File[ is.na(File) ] <- ""
  scenario <- visioneval::getRunParameter("Scenario",Default="Unknown Scenario",Param_ls=private$RunParam_ls)

  splitGroupTableName <- strsplit(ds$groupname, "/")
  if ( length(Description) != length(splitGroupTableName) ) stop("Inconsistent table<->description correspondence")

  maxLength <- max(unlist(lapply(splitGroupTableName, length)))
  if ( maxLength != 3 ) {
    visioneval::writeLog(Level="warn",paste0("Model state at ",self$resultsPath," is incomplete (",maxLength,")"))
    return(list())
  }
  splitGroupTableName <- lapply(splitGroupTableName , function(x) c(x, rep(NA, maxLength-length(x))))
  # splitGroupTableName is a list of character vectors with Group, Table, Name components

  fieldGTN <- do.call(rbind.data.frame,splitGroupTableName)
  names(fieldGTN) <- c("Group","Table","Name")

  # Build parallel data.frame for Inputs (including File parameter)
  # message("Input data frame...")
  Index <- data.frame(
    Group       = fieldGTN$Group,
    Table       = fieldGTN$Table,
    Name        = fieldGTN$Name, # Should be identical to ds$name
    Description = Description,
    Units       = Units,
    Module      = Module,
    Scenario    = scenario,
    File        = File,          # "" if not an Input
    InputDir    = InputDir       # "" if not an Input
  )

  # GroupTableName is now a data.frame with nine columns
  # complete.cases blows away the rows that have any NA values
  # (each row is a "case" in stat lingo, and the "complete" ones have a non-NA value for each column)
  ccases <- stats::complete.cases(Index)
  Index <- Index[ccases,]
  self$modelIndex <- Index
  invisible(self$modelIndex)
}

ve.results.list <- function(pattern="", details=FALSE, selected=TRUE, ...) {
  # Show details about model fields
  # selected = TRUE shows just the selected fields
  # selected = FALSE shows all fields (not just unselected)
  # pattern matches (case-insensitive regexp) some portion of field name
  # details = TRUE returns a data.frame self$modelIndex (units, description)
  # detail = FALSE returns just the "Name" vector from self$modelIndex
  
  if ( ! self$valid() ) stop("Model has not been run yet.")

  filter <- if ( missing(selected) || selected ) {
    self$selection$index
  } else {
    rep(TRUE,nrow(self$modelIndex))
  }
  if ( ! missing(pattern) && is.character(pattern) && nzchar(pattern) ) {
    filter <- filter & grepl(pattern,self$modelIndex$Name,ignore.case=TRUE )
  }

  if ( missing(details) || ! details ) {
    ret.value <- with( self$modelIndex[ filter, ], paste(Group,Table,Name,sep="/") ) # generates a character vector
  } else {
    ret.value <- self$modelIndex[ filter, ] # Generates a data.frame with all columns
  }
  return(unique(ret.value))
}

# Helper function to attach DisplayUnits to a list of Group/Table/Name rows in a data.frame
addDisplayUnits <- function(DisplayUnitsFilePath,GTN_df) {
  # GTN_df is a data.frame with "Group","Table","Name" rows for each Name/field for which display
  #  units are sought. Always re-open the DisplayUnits file, as it may have changed since the last
  #  run.
  if ( is.na(DisplayUnitsFilePath) ) {
    return( cbind(GTN_df,DisplayUnits=NA) )
  }
  fn <- normalizePath(DisplayUnitsFilePath,winslash="/",mustWork=FALSE)
  if ( ! file.exists(fn) ) {
    visioneval::writeLog( Level="warn",
      c("Specified DisplayUnits file does not exist (using default units):",fn)
    )
    return( cbind(GTN_df,DisplayUnits=NA) )
  }
  displayUnits <- try(read.csv(fn),silent=TRUE)   # May fail for various reasons
  if ( ! "data.frame" %in% class(displayUnits) ) {
    visioneval::writeLog( Level="warn",
      c(
        "Error reading DisplayUnits file:",
        fn,
        paste("Error:",conditionMessage(attr(displayUnits,"condition")))
      )
    )
    return( cbind(GTN_df,DisplayUnits=NA) )
  }
  if ( ! all( c("Group","Table","Name","DisplayUnits") %in% names(displayUnits) ) ) {
    visioneval::writeLog( Level="warn",
      c("Specified DisplayUnits file does not have correct columns:",fn,
        paste("Columns:",names(displayUnits),collapse=", ")
      )
    )
    return( cbind(GTN_df,DisplayUnits=NA) )
  }
  displayUnits <- try( merge(GTN_df,displayUnits,by=c("Group","Table","Name"),all.x=TRUE), silent=TRUE )
  if (
    ! "data.frame" %in% class(displayUnits) ||
    ! all( c("Group","Table","Name","DisplayUnits") %in% names(displayUnits) )
  ) {
    if ( "data.frame" %in% class(displayUnits) ) {
      displayUnits <- paste("Bad Fields - ",names(displayUnits),collapse=", ")
    } else {
      displayUnits <- conditionMessage(attr(displayUnits,"condition"))
    }
    visioneval::writeLog( Level="warn",
      c(
        "Error reading DisplayUnits file:",
        fn,
        paste("Error:",displayUnits)
      )
    )
    return( cbind(GTN_df,DisplayUnits=NA) )
  }
  # get here with displayUnits being GTN_df, augmented by matching DisplayUnits
  return(displayUnits)
}
  

ve.results.inputs <- function( fields=FALSE, module="", filename="" ) {
  # fields=TRUE, show all names of inputs
  # fields=FALSE, just show the module, file, input directory
  if ( ! self$valid() ) stop("Model has not been run yet.")

  if ( ! missing(fields) && fields ) {
    ret.fields <- c("Module","Group","Table","Name","File","InputDir","Units","Description")
  } else {
    ret.fields <- c("Module","Name","File","InputDir")
  }

  filter <- nzchar(self$modelIndex$File)
  if ( !missing(module) && nzchar(module) ) {
    filter <- filter & grepl(module,self$modelIndex$Module)
  }
  if ( !missing(filename) && nzchar(filename) ) {
    filter <- filter & grepl(filename,self$modelIndex$File)
  }

  ret.value <- unique(self$modelIndex[ filter, ret.fields ])
  return( ret.value[order(ret.value$InputDir,ret.value$File),] )
}

ve.results.units <- function() {
  # Not implemented yet
  NULL
}

ve.results.extract <- function(
  saveTo=visioneval::getRunParameter("OutputDir",Param_ls=private$RunParam_ls),
  overwrite=FALSE,
  select=NULL # replaces self$selection if provided
) {
  if ( ! self$valid() ) stop("Model State contains no results.")
  if ( is.null(select) ) select <- self$selection else self$selection <- select
  if ( is.na(select$selection) || length(select$selection)<1 ) {
    stop("Nothing selected to extract.")
  }

  saving <- is.character(saveTo) && nzchar(saveTo)[1]
  if ( saving ) {
    saveTo <- saveTo[1]
    outputPath <- if ( isAbsolutePath(saveTo) ) saveTo else file.path(self$modelDir,saveTo)
    if ( ! dir.exists(saveTo) ) dir.create(saveTo,showWarnings=FALSE)
    if ( ! dir.exists(saveTo) ) {
      stop(
        visioneval::writeLog( Level="error",
          c( "Output directory not available:",saveTo )
        )
      )
    }
  }

  extract <- self$modelIndex[ select$selection, c("Name","Table","Group") ]
  displayUnits <- visioneval::getRunParameter("DisplayUnitsFile",Param_ls=Param_ls)
  extract <- addDisplayUnits(displayUnits,extract)

  extractTables <- unique(extract[,c("Group","Table")])
  extractGroups <- unique(extractTables$Group)

  QueryPrep_ls <- self$queryprep()
  outputList <- list()
  results <- list()
  for ( group in extractGroups ) {
    # Build Tables_ls for readDatastoreTables
    Tables_ls <- list()
    tables <- extractTables$Table[ extractTables$Group == group ]
    if ( length(tables)==0 ) next # should not happen given how we built extract
    for ( table in tables ) {
      fields <- extract[ extract$Group==group & extract$Table==table,c("Name","DisplayUnits") ]
      dispUnits <- fields$DisplayUnits
      names(dispUnits) <- fields$Name
      Tables_ls[[table]] <- dispUnits
    }

    # Get a list of data.frames, one for each Table configured in Tables_ls
    Data_ls <- readDatastoreTables(Tables_ls, group, QueryPrep_ls)

    # Report errors from readDatastoreTables
    HasMissing_ <- unlist(lapply(Data_ls$Missing, length)) != 0
    if (any(HasMissing_)) {
      WhichMissing_ <- which(HasMissing_)
      Missing_ <- character(0)
      for (i in WhichMissing_) {
        Missing_ <- c(
          Missing_,
          paste0(
            names(Data_ls$Missing)[i], " (",
            paste(Data_ls$Missing[[i]], collapse = ", "), ")"
          )
        )
      }
      msg <- paste("Missing Tables (Datasets):",paste(Missing_, collapse = "\n"),sep="\n")
      stop( writeLog( msg, Level="error" ) )
    }

    # Process the table data.frames into results
    dataNames <- names(Data_ls$Data)
    newTableNames <- paste(group,dataNames,sep=".")
    if ( saving ) {
      # Push each data.frame into a file, and accumulate a list of file names to return
      # TODO: File name template is hard-coded; maybe we'll change that one day
      #   (e.g. using an sprintf format or the glue package)

      # Build file name template
      lastChanged <- self$ModelState$LastChanged
      timeWritten <- paste0("(",paste("Written",Sys.time(),sep="_"),")")
      if ( ! is.null(lastChanged) ) {
        timeWritten <- paste(format(lastChanged,"%Y-%m-%d_%H%M"),timeWritten,sep="+")
      }
      Files <- paste0(paste(group,dataNames,format(lastChanged,"%Y-%m-%d_%H%M%S"),sep="_"),".csv")
      names(Files) <- dataNames;

      # Write the files
      for ( table in dataNames ) {
        write.csv(Data_ls$Data[[table]],file=Files[table],row.names=FALSE)
      }

      # Accumulate results list (names on list are "group.table")
      names(Files) <- newTableNames
      results[ names(Files) ] <- as.list(Files)
    } else {
      # Otherwise, if not saving, accumulate the list of data.frames (named as "group.table")
      names(Data_ls$Data) <- newTableNames
      results[ names(Data_ls$Data) ] <- Data_ls$Data
    }
  }
  invisible(results)
}

# Update this selection, or just return what is already selected
ve.results.select <- function(select=integer(0)) {  # integer(0) says select all by default. Use NA or NULL to select none
  if ( ! is.null(select) ) {
    self$selection <- VESelection$new(self,select=select)
  }
  return(self$selection)
}

ve.results.queryprep <- function() {
  visioneval::prepareForDatastoreQuery(
    DstoreLocs_ = file.path(self$resultsPath,self$ModelState$DatastoreName),
    DstoreType  = self$ModelState$DatastoreType
  )
}

ve.results.print <- function(details=FALSE) {
  # Update for output
  cat("VEResults object for these results:\n")
  print(self$resultsPath)
  cat("Output is valid:",self$valid(),"\n")
  if ( ! details ) {
    sel <- length(self$selection$selection)
    all <- nrow(self$modelIndex)
    if ( sel < all ) {
      cat("Selected",sel,"out of",all,"fields.\n")
      print(self$selection) # Just the field names
    } else cat("Selected all fields.\n")
  } else {
    print(self$selection,details=TRUE)
  }
}

# Here is the VEResults R6 class
# One of these is constructed by VEModel$output()

VEResults <- R6::R6Class(
  "VEResults",
  public = list(
    # public data
    Name = NULL,
    resultsPath=NULL,
    modelDir=NULL,
    ModelState=NULL,
    modelIndex=NULL,
    selection=NULL,

    # methods
    initialize=ve.results.init,
    index=ve.results.index,          # Index Datastore from ModelState (part of init)
    valid=ve.results.valid,          # has the model been run, etc.
    select=ve.results.select,        # return the object's selection object
    extract=ve.results.extract,      # generate files or data.frames from model results
    export=ve.results.extract,       # alias for 'extract'
    list=ve.results.list,            # show the modelIndex
    queryprep=ve.results.queryprep,  # For query or other external access
    print=ve.results.print,          # summary of model results (index)
    units=ve.results.units           # TODO: Set units on field list (modifies self$modelIndex)
  ),
  private = list(
    queryObject=NULL,               # object to manage queries for this output
    outputPath=NULL,                # root for extract
    RunParam_ls=NULL
  )
)

ve.select.initialize <- function( results, select=integer(0) ) {
  # default select (integer(0)) selects everything
  # self$selection is just a list of integers pointing to rows
  #  in self$results$modelIndex
  self$results <- results
  rows <- self$parse(select)
  if ( is.null(rows) || any(is.na(rows)) ) {
    self$selection <- as.integer(NA) # no rows selected
  } else if (
    ! is.numeric(rows) ||
    length(rows)==0 ||
    ! min(rows)>0 ||
    max(rows)>nrow(self$results$modelIndex) ) {
    self$selection <- 1:nrow(self$results$modelIndex)
  } else {
    self$selection <- rows
  }
}

ve.select.copy <- function(select) VESelection$new(self$results,self$selection)

ve.select.print <- function(details=FALSE) {
  # print the selected fields
  if ( ! details ) {            # just the field names (see below)
    print( self$fields() )
  } else {                      # full data frame of selected model results
    print( self$results$modelIndex[ self$selection, ] )
  }
}

ve.select.groups <- function() {
  if ( ! self$results$valid() ) stop("Model has not been run yet.")
  if ( any(is.na(self$selection)) ) {
    message("No groups selected")
    return(character(0))
  }
  idxGroups <- unique(self$results$modelIndex[self$selection,c("Group"),drop=FALSE])
  return(sort(idxGroups)) # Group
}

ve.select.tables <- function() {
  if ( ! self$results$valid() ) stop("Model has not been run yet.")
  if ( any(is.na(self$selection)) ) {
    message("No tables selected")
    return(character(0))
  }
  idxTables <- unique(self$results$modelIndex[self$selection,c("Group","Table")])
  return(sort(paste(idxTables$Group,idxTables$Table,sep="/"))) # Group/Table
}

ve.select.fields <- function() {
  # extract fields from the index where groups and tables are selected
  if ( ! self$results$valid() ) stop("Model has not been run yet.")
  if ( any(is.na(self$selection)) ) {
    message("No fields selected")
    return(character(0))
  }
  idxFields <- self$results$modelIndex[self$selection,c("Group","Table","Name")]
  return(sort(paste(idxFields$Group,idxFields$Table,idxFields$Name,sep="/"))) # Group/Table/Name
}

# Internal helper function to make a selection vector out of various other types of objects
ve.select.parse <- function(select) {
  # Though select can be a vector of field names, they need to be the full Group/Table/Name field names,
  #  so you should get them from ve.select.find, rather than manually construct them.
  # if select is NA, return NA
  # select can be another VESelection
  #   if it is the same model, just copy its selection
  #   if not the same model, get other selection's VEResults object and parse that
  if ( "VESelection" %in% class(select) ) {
    if ( select$results$path != self$results$path ) {
      select <- select$fields()
      # fall through to parse the character strings
    } else {
      return( select$selection )
    }
  }
  # select can be another VEResults object
  #   if the other VEResults is not from the same model, use its $fields set of names
  #   then parse as a character vector
  #   if it is the same model, just copy its selection
  if ( "VEResults" %in% class(select) ) {
    if ( select$path != self$results$path ) {
      select <- select$selection$fields()
    } else {
      return( select$selection$selection )
    }
  }
  # select can be a character vector
  #   split the vector into group/table/name, providing defaults
  # locate the rows with matching group/table/name in results$modelIndex
  #   That vector of row indices becomes the selection to act on
  if ( is.character(select) ) {
    build <- integer(0)
    for ( s in select ) {
      t <- unlist(strsplit(s,"/"))
      name <- c( rep(NA,3-length(t)), t )
      if ( is.na(name[3]) || ! nzchar(name[3]) ) next  else field=name[3]
      if ( is.na(name[2]) || ! nzchar(name[2]) ) table <- NULL else table=name[2]
      if ( is.na(name[1]) || ! nzchar(name[1]) ) group <- NULL else group=name[1]
      build <- union( build, self$find(Name=field,Group=group,Table=table,as.object=FALSE) )
    }
    select <- build; # should be a vector of integers
  }
  
  # if select is a numeric vector, validate its range and return it
  if ( is.numeric(select) ) {
    if ( length(select)>0 ) {
      if ( any(is.na(select)) ) return( as.integer(NA) )
      if ( ! ( min(select)>0 && max(select)<=nrow(self$results$modelIndex) ) ) {
        message("Field selection out of range")
        return( as.integer(NA) )
      }
    }
    return( select )
  }
  message("Invalid field selection specification")
  message(deparse(select))
  return( as.integer(NA) )
}

#' Assign new selection to VESelection
#'
#' @param select an object to be made into a VESelection and then assigned to this one
#' @return the VESelection that was modified
#' @export
"<-.VESelection" <- function(select) self$select(select)

# Return a reference to this selection, changing its indices if an argument is provided
ve.select.select <- function(select) {
  if ( ! missing(select) ) self$selection <- self$parse(select)
  return(self)
}

# Find does NOT alter the object it is called on.
# It either produces a new VESelection from the matching elements of self$selection (as.object==TRUE)
# OR it products a vector of matching element indices (as.object==FALSE)
ve.select.find <- function(pattern=NULL,Group=NULL,Table=NULL,Name=NULL,as.object=TRUE) {
  # if pattern (regexp) given, find names matching pattern (only within the "fields" part)
  # if group or table not specified, look in any group or table
  # return vector of indices for matching rows or (as.object==TRUE) a new VESelection object
  searchGroup <- Group
  searchTable <- Table
  searchName  <- Name
  newSelection <- self$selection
  newSelection <- with( self$results$modelIndex, {
    if ( !is.null(pattern ) ) {
      fld <- grepl(pattern,Name,ignore.case=TRUE)     # RegEx search for name
    } else if ( !is.null(searchName) ) {
      fld <- Name == searchName;                      # Exact name match
    } else {
      fld <- rep(TRUE,nrow(self$results$modelIndex))  # Start with all selected
    }
    if ( !is.null(searchGroup) ) {
      if ( searchGroup %in% c("Year","Years","AllYears") ) {  # shorthand for non-Global group
        group <- Group != "Global"
      } else {
        group <- Group == searchGroup
      }
      fld <- fld & group
    }
    if ( !is.null(searchTable) ) fld <- fld & Table==searchTable
    which(fld)
  })
  if ( length(newSelection) == 0 ) newSelection <- as.integer(NA)
  if ( as.object ) {
    return(VESelection$new(self$results, select=newSelection))
  } else {
    return(newSelection)
  }
}

# Add another selection to self (add + assign)
# Matching indices will be included
ve.select.add <- function(select) {
  select <- self$parse(select)
  self$selection <- union(self$selection,select)
  return(self)
}

# Remove contents of another selection from self (remote + assign)
# Matching indices in select will be removed
ve.select.remove <- function(select) {
  select <- self$parse(select)
  self$selection <- setdiff(self$selection,select)
  return(self)
}

# Keep only fields that are in both self and select (logical "and")
# Indices in both will be kept, and those present in only one will be removed
ve.select.and <- function(select) {
  select <- self$parse(select)
  self$selection <- intersect(self$selection,select)
  return(self)
}

# 
ve.select.all <- function() {
  self$selection <- 1:nrow(self$results$modelIndex)
  return(self)
}

ve.select.none <- function() {
  self$selection <- integer(NA)
  return(self)
}

# Build data.frames based on selected groups, tables and dataset names
ve.select.extract <- function(
  saveTo=visioneval::getRunParameter("OutputDir",Param_ls=private$RunParam_ls),
  overwrite=FALSE
) {
  # Delegates to the result object, setting its selection in the process
  return( self$results$extract(saveTo,overwrite,quiet,select=self) )
}

#' Conversion method to turn a VESelection into a vector of selection indices
#'
#' @param select a VESelection object (or something that can be coerced to one)
#' @return an integer vector of selected fields
#' @export
as.integer.VESelection <- function(select) select$selection

# The VESelection R6 class
# This interoperates with VEResult to keep track of what to print
VESelection <- R6::R6Class(
  "VESelection",
  public = list(
    # public data
    selection = integer(0),
    results = NULL,

    # methods
    initialize=ve.select.initialize,
    copy=ve.select.copy,          # Create a new selection object with the same results and indices
    print=ve.select.print,
    extract=ve.select.extract,
    export=ve.select.extract,
    find=ve.select.find,
    parse=ve.select.parse,
    select=ve.select.select,      # assign - set self to other selection value
    add=ve.select.add,            # "union" - indices in either selection
    remove=ve.select.remove,      # "setdiff" - indices not in other selection
    and=ve.select.and,            # "intersection" - only indices in both selections
    or=ve.select.add,             # alias for "add"
    all=ve.select.all,            # select all indices
    none=ve.select.none,          # select no indices (empty selection)

    # Field lists (read-only)
    groups=ve.select.groups,
    tables=ve.select.tables,
    fields=ve.select.fields
  )
)

#' Open VisionEval results from a directory
#'
#' @description
#' `openResults` opens a directory containing VisionEval model run results and
#'    returns a VEObject instance that can be used to extract the results or
#'    to perform queries.
#'
#' @details
#' See `vignette(package='VEModel')` for available help and reference materials.
#'   The basic use of `openModel` is also described in the VisionEval Getting-Started
#'   document on the VisionEval website (also in the VisionEval installer).
#'
#' The path provided as a parameter needs to contain ModelState.Rda and Datastore, using the names
#'   for those elements in the VisionEval run parameters ModelStateFileName and DatastoreName
#'   respectively. Generally, it is most reliable to open an output using the model object returned
#'   by VEModel::openModel, since that will ensure that the same run environment is used to find the
#'   result files as when those results were created. The openResults file does not load any
#'   configurations.
#'
#' @param path A relative or absolute path to a directory (default is the working directory)
#'   in which VisionEval results can be found for a single model run, stage or scenario
#'   combination.
#' @return A VEResults object giving access to the VisionEval results in `path`
#' @export
openResults <- function(path=NULL) {
  if ( ! dir.exists(path) ) path <- getwd()
  return(VEResults$new(path))
}
