# Author: Jeremy Raw

# VEModel Package Code

#####################
# RUNTIME ENVIRONMENT
#####################

# The ve.env environment is accessed via VEModel::runtimeEnvironment.

ve.env <- new.env()
ve.env$RunParam_ls <- list()

#ACCESS R ENVIRONMENT FOR MODEL RUN
#==================================
#' Access an R environment for the runtime installation.
#'
#' \code{modelEnvironment} returns an environment for managing the ve.runtime directory and its
#' components, the default runtime parameters and other runtime needs. That environment contains the
#' default RunParams_ls structure plus other components needed to manage global state for VEModel
#' classes.
#'
#' \code{modelEnvironment} holds the RunParam_ls settings from the runtime directory (or its
#' "config" subdirectory if that exists). The runtime directory is either the current directory or
#' specified in a system environment variable VE_RUNTIME; see \code{setRuntimeDirectory()}.
#' 
#' The runtime environment settings form the basis for settings used by individual models, and can
#' define things like the RandomSeed or DatastoreType that are rarely changed in individual models.
#'
#' @section Model Environment:
#'
#' VEModel supports the following directory structures for models to configure the location of
#' $export/$extract and $query artifacts as well as the models themselves.

#' The visioneval framework itself defaults to a simpler directory structure (for "classic"
#' VisionEval models) which apply only to the inputs and results for a single model. If you "source"
#' a run_model.R script without loading the VEModel package, you will get the classic output
#' structure (which can still be opened by VEModel). If you load the VEModel package, it will
#' understand the classic structure, but will use these settings to manage new models, new model
#' runs, and outputs generated using VEModel, VEResults or VEQuery functions. Override them in a
#' model-specific VisionEval.cnf file (in ModelDir) to make it as much like the old behavior as you
#' wish. Set the various directories to "." or "" to ignore them and just use ModelDir.
#'
#' Here is a summary of the VEModel defaults. To see parameters and defaults defined in the
#' visioneval framework itself, see \code{visioneval::defaultVERuntimeParameters}.
#'
#' When VEModel loads a model, it sets ModelDir to the full path of the model (which may or may not
#' include ModelRoot, e.g. if a model is opened with an absolute path). The visioneval framework
#' itself uses the working directory for ModelDir (where "run_model.R" will presumably be found).
#'
#' Then VEModel will open the model configuration file by looking in ModelDir for a visioneval.yml
#' file (see \code{loadModelConfiguration}).
#'
#' If that configuration does not override the standard locations, and no ModelSetup is defined (in
#' ModelDir/ScriptsDir or in the root ModelDir), the ModelScriptFile (see visioneval parameters)
#' will be sought using the ModelScript pattern, in ModelDir/ScriptsDir and then in ModelDir (see
#' the framework for ModelDir definition).
#'
#' QueryDir is the default location for Query Specification definition files. OutputDir receives
#' results of the $extract/$export and $query functions. DisplayUnitsFile is the basename of the
#' file used to provide model units. It will be sought in ParamDir for the model, and if not found
#' there will be sought in ve.runtime/config. QueryFileName is a default for creating a query if no
#' other name is provided. It will be disambiguated by appending digits to the root name (i.e.
#' before the .VEqry extenstion). QueryOutputTemplate describes the filename generated by $query
#' within its results directory (see the VEQuery R6 object documentation).
#'
#' \describe{
#'   \item{ModelDir}{Default value is provided in the visioneval framework. In VEModel, ModelDir is
#'   constructed when a model is loaded. It is then used as the root for most of the following parameters,
#'   as well as the model parameters such as ParamDir and InputsDir defined in the framework.}
#'   \item{ModelRoot}{Where to search in ve.runtime for model directories (default "models")}
#'   \item{ModelSetup}{File name for 'new style' model (default "model_setup.yml")}
#'   \item{ModelScript}{Regular expression for run_model file name (default "run_model\\.R")}
#'   \item{ScriptsDir}{Directory within a model to search for run_model.R or RunStep scripts
#'   (default "scripts")}
#'   \item{ResultsDir}{Directory within a model to place the current results, and to provide a
#'   basename for archived results (default "results")}
#'   \item{StageDir}{Directory within ResultsDir to place results from a "stage" or "RunStep", and
#'   to provide a basename for archived results; this will be set in $run if the model has
#'   stages. (default "results")}
#'   \item{QueryDir}{Where to look for query definitions for this model (default "queries")}
#'   \item{OutputDir}{Where to put results generated by $extract/$export or $query, relative to
#'   ModelDir (default "output")}
#'   \item{DisplayUnitsFile}{Name of the file describing unit conversions to be applied to
#'   Datastore fields when using $export/$extract (default "display_units.csv")}
#'   \item{QueryFileName}{Default name for a newly constructed query (within QueryDir) (default
#'   "New-Query.VEqry")}
#'   \item{QueryOutputTemplate}{File template for output from the $query function, within
#'   OutputDir/query_%datetime% (default "Measures_%scenario%_%years%_%geography%.csv")}
#' }
#'
#' @return an R environment "ve.env"
#' @export
runtimeEnvironment <- function() { ve.env }

# Package defaults for VisionEval getRunParameter
# Some of these are different from the framework defaults (e.g. ResultsDir).
# The package defaults will override.

default.parameters.table = list(
  ModelRoot           = "models",
  ModelScript         = "run_model\\.R",
  ScriptsDir          = "scripts", # Will collapse to '.' if not already present
  ResultsDir          = "results", # Will create if not already present
  StageDir            = ".", # Constructed at runtime within ResultsDir if model has stages
  OutputDir           = "output",  # Will create if not already present
  QueryDir            = "queries", # Home for defined queries within the ModelDir
  DisplayUnitsFile    = "display_units.csv",
  QueryFileName       = "New-Query",
  QueryOutputTemplate = "Measures_%scenario%_%years%_%geography%.csv"
)

#GET DEFAULT PARAMETERS
#======================
#' Hook to add default values for key parameters in the VEModel package
#'
#' \code{VEPackageRunParameters} extends \code{visioneval::defaultVERuntimeParameters} to provide
#' additional Parameters and Defaults for VEModel functions that can be accessed seamlessly. You can
#' call this function directly (e.g. to see what parameters are defined and defaulted in VEModel).
#' Internally VEModel uses \code{visioneval::defaultVERuntimeParameters} to access these parameters,
#' so it doesn't have to remember whether specific defaults are defined in visioneval itself or in
#' VEModel (and one can transparently move the default definitions back and forth).
#'
#' @param Param_ls a list (possibly empty) of already-defined parameters
#' @return a named list for parameters not present in Param_ls containing default values for those
#'   parameters
#' @export
VEPackageRunParameters <- function(Param_ls=list()) {
  defaultParams_ls <- default.parameters.table[
    which( ! names(default.parameters.table) %in% names(Param_ls) )
  ]
  if ( length(defaultParams_ls)>0 ) {
    defaultParams_ls <- visioneval::addParameterSource(defaultParams_ls,"Package VEModel Default")
    Param_ls <- visioneval::mergeParameters(defaultParams_ls,Param_ls) # Param_ls will override
  }
  return(Param_ls)
}

#LOAD RUNTIME CONFIGURATION
#==========================
#' Load a VisionEval.cnf file from a directory into the runtime environment
#'
#' \code{loadRuntimeConfig} merges a configuration file from a directory into the runtime R
#' environment. With no parameters it will read and merge the file's contents into the system
#' runtime paramters list (so call it after changing the configuration file to bring the in-memory
#' version up to date). See \code{visioneval::loadConfiguration} for more details.
#'
#' @param ParamDir is the directory in which to seek visioneval.cnf
#' @param ParamFile is a specific file to seek (rather than looking for one of the default file
#'   names). Note that an error will be raised if that file is specified but does not exist.
#' @return The updated runtime parameters list (which is also modified in place)
#' @export
loadRuntimeConfig <- function(ParamDir=NULL,ParamFile=NULL) {
  # Function loads configuration from ParamDir/VisionEval.cnf
  # ParamDir defaults to:
  #    ve.runtime/config if ve.runtime defined and "config" exists
  #    else ve.runtime (possibly itself defaulted) if "config" does not exist
  ve.env <- runtimeEnvironment()
  if ( is.null(ve.env$ve.runtime) ) setRuntimeDirectory() # VE_RUNTIME or getwd()
  if ( is.null(ParamDir) ) {
    ParamDir <- file.path(ve.env$ve.runtime,"config")
    if ( ! dir.exists(ParamDir) ) ParamDir <- ve.env$ve.runtime
  }
  if ( ! exists("RunParam_ls",envir=ve.env,inherits=FALSE) ) ve.env$RunParam_ls <- list()
  ve.env$RunParam_ls <- visioneval::loadConfiguration(ParamDir=ParamDir,ParamFile=ParamFile,override=ve.env$RunParam_ls)
  invisible( ve.env$RunParam_ls )
}

#GET RUNTIME PARAMETERS
#======================
#' Return runtime base RunParam_ls (loading it if not present)
#'
#' \code{getRuntimeParameters} gets a subset of the current runParameters by name. It does NOT
#' supply default values. It returns the ones that are defined.
#'
#' @param paramNames is a character vector of parameter names identifying a subset of runParameters
#'   to retrieve. If not provided, return all defined parameters (but not any that are defaulted).
#' @return A list of defined run parameters (possibly empty, if no parameters are defined)
#' @export
getRuntimeParameters <- function(paramNames=NULL) {
  RunParams_ls <- if ( is.null(ve.env$RunParam_ls) ) ve.env$RunParam_ls else loadRuntimeConfig()
  if ( is.character(paramNames) ) RunParams_ls <- RunParams_ls[names(RunParams_ls) %in% paramNames]
  return(RunParams_ls)
}

#' Set the VisionEval runtime directory for model management
#'
#' \code{setRuntimeDirectory} runs when the VEModel package is loaded. If R starts with a different
#' working directory, this function can replace \code{setwd()} as it can be used in a single call
#' to set the VEModel runtime directory and to change the working directory.
#'
#' The working directory at the time this function was called is also saved as ve.env$start.dir.
#' It is consequently feasible to move back and forth between alternative runtime directories.
#'
#' Once can return to the original working directory using a line like this:
#' \code{setRuntimeDirectory(getRuntimeEnvironment()$start.dir)}
#'
#' When that line runs, start.dir will again be reset, so running that line repeatedly will toggle
#' between two directories (e.g. the one from which \code{R} was started and the one defined in the
#' VE_RUNTIME environment variable..
#'
#' @param Directory a specific directory (absolute or relative to getwd()) to use as the runtime. If
#' Directory is not provided, looks for a system environment variable VE_RUNTIME, and if that is not
#' defined, then uses the working directory.
#' @return The normalized path to the directory that has been selected as the ve.runtime
#' @export
setRuntimeDirectory <- function(Directory=NULL) {
  if ( is.null(Directory) ) {
    Directory <- if ( ! exists("ve.runtime",envir=ve.env,inherits=FALSE) ) {
      Sys.getenv("VE_RUNTIME",unset=getwd())
    } else ve.env$ve.runtime
  } else {
    Directory <- normalizePath(Directory,winslash="/",mustWork=FALSE)
    if ( ! dir.exists(Directory) ) {
      Directory <- getwd()
    }
  }
  # returns the working directory from before this call
  ve.env$start.dir <- getwd()
  if ( getwd() != Directory ) {
    setwd(Directory)
  }
  return( ve.env$ve.runtime <- getwd() )
}

# Get the runtime directory (ve.runtime)
#' Get the runtime directory
#' Return the runtime directory established when VEModel package is loaded or by a later call to
#'   \code{setRuntimeDirectory}. If the runtime directory has not yet been set, set it to the
#'   working directory.
#' @return The ve.runtime directory from the package environment, ve.env
#' @export
getRuntimeDirectory <- function() {
  Directory <- ve.env$ve.runtime
  if ( is.null(Directory) ) Directory <- setRuntimeDirectory()
  return(Directory)
}

# INTERNAL FUNCTION TO SET BASIC RUN PARAMETERS
#==============================================
# Set up a Runtime environment consistently by providing
# model-run-specific parameters (see list of parameters)
# Used internally when loading ModelState files and running Models. A specific model's
# configuration may replace these with something else.
# TODO: review the process with the new VEModel::ve.env environment and its RunParam_ls
ve.model.setupRunEnvironment <- function(
  Owner,
  PreviousState=list(),
  Param_ls=list(),
  RunModel=FALSE,
  ModelDir=getwd(),
  ResultsDir=".",         # Should be relative to ModelDir
  InputPath=".",          # Should be relative to ModelDir
  ModelScriptFile = NULL, # Override if provided
  LogLevel="warn"
) {
  # Set up ve.model environment with run parameters
  ve.model <- visioneval::modelEnvironment(Clear=Owner)
  ve.model$RunModel <- RunModel
  ve.model$ModelStateStages <- PreviousState; # previously loaded model states
  addParams_ls <- list(
    ResultsDir      = ResultsDir,
    ModelDir        = ModelDir,
    InputPath       = InputPath,
    LogLevel        = LogLevel
  )
  if ( ! is.null(ModelScriptFile) ) addParams_ls <- c(addParams_ls,list(ModelScriptFile=ModelScriptFile))
  addParams_ls <- visioneval::addParameterSource(addParams_ls,paste0("Owner))
  ve.model$RunParam_ls <- visioneval::mergeParameters(Param_ls,addParams_ls) # addParams_ls will override

  invisible(ve.model$RunParam_ls)
}

# MAKE A UNIQUE FILE NAME
#========================
#  Get unique file name based on newName in folder newPath
#  NewPath is the directory it should go in, newName is the name to disambiguate
getUniqueName <- function(newPath,newName) {
  newModelPath <- file.path(newPath,newName)
  tryName <- newName; try <- 1
  while ( dir.exists(newModelPath) ) {
    tryName <- paste0(newName,"(",try,")")
    newModelPath <- file.path(newPath,tryName)
    try <- try+1
  }
  return (newModelPath)
}

# CHECK IF PATH IS ABSOLUTE
# =========================
#  return TRUE if modelPath looks like an absolute file path
isAbsolutePath <- function(modelPath,collapse=TRUE) {
  absolute <- grepl("^([[:alpha:]]:|[\\/])",modelPath)
  if (collapse) absolute <- any(absolute)
  return(absolute)
}

# NORMALIZE A VISIONEVAL PATH
# ===========================
# Like the R built-in normalizePath, but better handling for missing path components
# NOTE: Do we need this? Standard normalize path seems to handle empty path elements...
# Always does winslash="/"
normalizePath <- function(
  paths,                # character vector of file paths
  RootDir="",           # prefixed onto all relative paths
  mustWork=FALSE,       # or NA (warning) or TRUE (error) if not existing
  winslash="/"          # passed through
) {
  elements <- unlist( lapply(
    strsplit(paths,split="[\\/]"),
    function(x) {
      x[!nzchar(x)] <- "."
      paste(x,collapse="/")
    }
  ) )
  RootDir <- RootDir[1]
  if ( nzchar(RootDir) ) {
    relative <- !isAbsolutePath(elements,collapse=FALSE)
    elements[relative] <- paste(RootDir,elements[relative],sep="/")
  }
  return( base::normalizePath(elements,winslash=winslash,mustWork=mustWork) )
}
